# 更新失败问题修复

## 🐛 问题描述

更新时，批处理脚本无法找到新下载的 EXE 文件。

### 用户反馈

> 下载完成后重命名了旧文件，但是新文件没有 move 成功，我也没有找到新文件的原路径

### 批处理脚本日志

```batch
echo Installing new version...
move /y "C:\Users\liyin\AppData\Local\Temp\tmpjjjj2622\XexunRTT_new.exe" "E:\coder\RTT2UART2\dist\XexunRTT_v2.4.exe"
```

**问题**：临时目录 `tmpjjjj2622` 中的文件不存在！

---

## 🔍 根本原因

### 代码执行流程

```python
def _apply_full_update(self, update_info: Dict, progress_callback=None) -> bool:
    temp_dir = None
    try:
        # 1. 创建临时目录
        temp_dir = Path(tempfile.mkdtemp())  # 例如: C:\...\Temp\tmpjjjj2622
        
        # 2. 下载文件到临时目录
        download_file = temp_dir / "XexunRTT_new.exe"
        self._download_file(update_info['full_url'], download_file, ...)
        
        # 3. 验证哈希
        new_hash = self._calculate_file_hash(download_file)
        
        # 4. 调用替换函数
        return self._replace_exe(download_file)  # ← 创建批处理脚本
        
    finally:
        # 5. 清理临时文件
        if temp_dir and temp_dir.exists():
            shutil.rmtree(temp_dir)  # ← 问题！立即删除了临时目录！
```

### _replace_exe_windows() 流程

```python
def _replace_exe_windows(self, new_exe: Path) -> bool:
    # 1. 创建批处理脚本（引用临时目录中的文件）
    script_content = f"""
    move /y "{new_exe}" "{self.current_exe}"  # ← new_exe 在临时目录中
    """
    
    # 2. 启动批处理脚本（异步）
    subprocess.Popen([str(script_path)], ...)
    
    return True  # ← 返回，进入 _apply_full_update 的 finally 块
```

### 时序图

```
时间  | 主程序                    | 批处理脚本
------|-------------------------|------------------
t=0   | 下载文件到临时目录           |
t=1   | 验证文件                  |
t=2   | 创建批处理脚本             |
t=3   | 启动批处理脚本（异步）       |
t=4   | 返回 _replace_exe()       |
t=5   | 进入 finally 块           |
t=6   | shutil.rmtree(temp_dir)  |  ← 临时目录被删除！
t=7   | 程序退出                  |
t=8   |                         | timeout 2秒延迟
t=9   |                         | 尝试 move 文件
t=10  |                         | ❌ 文件不存在！
```

**冲突**：
- 批处理脚本延迟 2 秒执行
- 但主程序在 finally 块中**立即删除**了临时目录
- 批处理脚本执行时，文件已经不存在了

---

## ✅ 修复方案

### 核心思路

**在 finally 块清理临时目录之前，将新文件复制到一个永久位置**

### 修复代码

```python
def _replace_exe_windows(self, new_exe: Path) -> bool:
    try:
        # 🔧 关键修复：将新文件复制到一个不会被删除的位置
        # 使用与当前 EXE 相同的目录，避免临时目录被清理
        permanent_new_exe = self.current_exe.parent / "XexunRTT_new.exe"
        
        logger.info(f"Copying new exe to permanent location: {permanent_new_exe}")
        shutil.copy2(new_exe, permanent_new_exe)  # ← 复制到永久位置
        
        # 创建更新脚本（现在引用永久位置）
        script_content = f"""@echo off
echo Installing new version...
move /y "{permanent_new_exe}" "{self.current_exe}"
...
"""
        
        with open(script_path, 'w', encoding='gbk') as f:
            f.write(script_content)
        
        logger.info(f"New exe ready at: {permanent_new_exe}")
        
        # 启动更新脚本
        subprocess.Popen([str(script_path)], ...)
        
        return True
```

### 新的执行流程

```
时间  | 主程序                          | 批处理脚本
------|--------------------------------|------------------
t=0   | 下载到临时目录: tmpxxx/file.exe   |
t=1   | 验证文件                        |
t=2   | 复制到永久位置: dist/XexunRTT_new.exe  |
t=3   | 创建批处理脚本（引用永久位置）      |
t=4   | 启动批处理脚本                   |
t=5   | 返回，进入 finally              |
t=6   | 删除临时目录（没关系，已复制）     |  ✅ 永久文件存在
t=7   | 程序退出                        |
t=8   |                               | timeout 2秒
t=9   |                               | move dist/XexunRTT_new.exe
t=10  |                               | ✅ 成功！
```

---

## 📊 修复前后对比

### 修复前

```batch
# 批处理脚本引用临时目录
move /y "C:\Users\xxx\AppData\Local\Temp\tmpjjjj2622\XexunRTT_new.exe" "dist\XexunRTT_v2.4.exe"
```

**问题**：
- ❌ 临时目录在批处理执行前就被删除
- ❌ 文件不存在
- ❌ 更新失败
- ❌ 旧文件已被重命名为 .old，但新文件安装失败
- ❌ 程序无法启动（旧文件是 .old，新文件不存在）

### 修复后

```batch
# 批处理脚本引用永久位置
move /y "E:\coder\RTT2UART2\dist\XexunRTT_new.exe" "E:\coder\RTT2UART2\dist\XexunRTT_v2.4.exe"
```

**优势**：
- ✅ 文件在永久位置，不会被清理
- ✅ 批处理脚本可以找到文件
- ✅ 更新成功
- ✅ 如果失败，可以从 .old 恢复

---

## 🔍 为什么之前没发现？

### 开发环境 vs 生产环境

**开发环境**：
- 可能临时目录清理延迟较长
- 或者系统比较慢，2秒延迟足够

**生产环境**：
- Python 的 `tempfile.mkdtemp()` 在程序退出时可能立即清理
- 或者 `finally` 块的 `shutil.rmtree()` 非常快
- 2秒延迟不够

### 竞态条件 (Race Condition)

```
主程序清理速度 vs 批处理脚本启动速度
```

如果主程序清理得快，批处理脚本慢，就会失败。

---

## 🛡️ 额外改进

### 1. 增加日志

```python
logger.info(f"Copying new exe to permanent location: {permanent_new_exe}")
logger.info(f"New exe ready at: {permanent_new_exe}")
logger.info("Update script started, application will exit now")
```

用户可以在日志中看到新文件的位置。

### 2. 批处理脚本清理

批处理脚本最后会删除自己：
```batch
del /f "%~f0"
```

如果更新成功，所有临时文件都会被清理：
- `XexunRTT_new.exe` → 被 move 到正式位置
- `_update.bat` → 自我删除
- `XexunRTT_v2.4.exe.old` → 下次更新时删除

---

## 🎯 测试验证

### 测试步骤

1. **编译新版本**
   ```bash
   rebuild_clean.bat
   ```

2. **部署到服务器**
   ```bash
   quick_deploy.bat dist\XexunRTT_v2.4.1.exe
   ```

3. **运行旧版本并触发更新**
   ```bash
   dist\XexunRTT_v2.4.exe
   ```

4. **查看日志**
   ```bash
   view_log.bat
   ```

### 期望日志

```
Copying new exe to permanent location: E:\coder\RTT2UART2\dist\XexunRTT_new.exe
Update script created: E:\coder\RTT2UART2\dist\_update.bat
New exe ready at: E:\coder\RTT2UART2\dist\XexunRTT_new.exe
Update script started, application will exit now
```

### 验证文件

在程序退出后、批处理执行前，检查：
```bash
dir dist\XexunRTT_new.exe
dir dist\_update.bat
```

两个文件都应该存在。

---

## 📝 相关文件

- `auto_updater.py` - 修复了 `_replace_exe_windows()` 方法
- `dist\_update.bat` - 批处理脚本（自动生成）
- `dist\XexunRTT_new.exe` - 新文件的永久副本（临时）

---

## 💡 经验教训

### 1. 异步操作要小心

当启动异步进程（如批处理脚本）时，确保它依赖的资源不会被过早清理。

### 2. finally 块的时机

`finally` 块在函数返回后立即执行，即使你启动了异步任务。

### 3. 临时目录的生命周期

不要依赖临时目录在程序退出后仍然存在。

### 4. 复制 vs 移动

- **复制**：安全，源文件保留
- **移动**：快速，但源文件被删除

对于更新场景，先复制到永久位置更安全。

---

## ✅ 修复验证清单

- [x] 修复 `_replace_exe_windows()` 方法
- [x] 添加日志输出
- [x] 新文件复制到永久位置
- [x] 批处理脚本引用永久位置
- [x] 提交修复
- [x] 创建说明文档

---

## 🚀 现在可以重新测试

```bash
# 1. 重新编译
rebuild_clean.bat

# 2. 部署新版本（2.4.1）
quick_deploy.bat dist\XexunRTT_v2.4.1.exe

# 3. 运行旧版本（2.4）并更新
dist\XexunRTT_v2.4.exe

# 4. 查看日志
view_log.bat
```

**这次更新应该能成功了！** 🎉

